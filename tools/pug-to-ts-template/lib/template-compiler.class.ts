import { isEmpty, isNull } from "lodash-es";
import fileSystem from "fs-extra";
import camelcase from "camelcase";
import { dirname, join, basename } from "path";

import { BaseCompiler } from "./base-compiler.class.js";
import { Writer } from "./writer.class.js";
import { MixinCompiler } from "./mixin-compiler.class.js";

import { transformClassArray } from "./utils/transform-class-array.js";

import {
  TPugAttribute,
  TPugTagNode,
  TPugTextNode,
  TPugBlockNode,
  TPugAnyNode,
  TPugInterpolatedTagNode,
  TPugCaseNode,
  TPugWhenNode,
  TPugMixinNode,
  TPugWhileNode,
  TPugEachNode,
  TPugCodeNode,
  TPugCommentNode,
  TPugBlockCommentNode,
  TPugConditionalNode,
  TPugIncludeNode
} from "./types/pug.types.js";
import { cpSync } from "fs";

type TCompilerVariableNames = {
  view: string;
  dataStructure: string;
  typedDataStructure: string;
  typedDataTemplate: string;
  templateFunctionConst: string;
  templateFunction: string;
};

export class TemplateCompiler extends BaseCompiler {
  options: { moduleName: string } & { [key: string]: any };
  ast: TPugBlockNode;
  indent: number = 1;
  nodeId: number = 0;
  parentTagId: number = 0;
  buffer: string[] = [];
  moduleName: string;
  variablesNames: TCompilerVariableNames;
  // DataStructure: IExternalBuffer[] = [];
  dataStructure: Writer;
  imports: Writer;
  body: Writer;
  // mixins: Writer;
  mixinCompilers: MixinCompiler[] = [];
  beforeBodyReturnIndex: number;
  constructor(ast: TPugBlockNode, options: { moduleName: string }) {
    super(ast);
    this.options = options;

    this.dataStructure = new Writer();
    this.imports = new Writer();
    this.moduleName = options.moduleName;
    const viewName = `${this.moduleName}View`;
    const dataStructure = `${viewName}Datastructure`;
    this.variablesNames = {
      view: viewName,
      dataStructure,
      typedDataStructure: `T${camelcase(dataStructure, { pascalCase: true })}`,
      typedDataTemplate: `T${viewName}TemplateData`,
      templateFunctionConst: `${camelcase(viewName)}Template`,
      templateFunction: `${camelcase(viewName)}TemplateFn`
    };
  }

  // override BaseCompiler.compile()
  compile() {
    this.bootstrap();
    return [
      this.imports.write(),
      this.body.write(),
      this.dataStructure.write()
    ].join("\n\n");
  }

  bootstrap() {
    this.imports.addLine("/**");
    this.imports.indent++;
    this.imports.addLine("* DO NOT EDIT THIS FILE DIRECTLY");
    this.imports.addLine(
      "* This file has been generated by the tool @bonsai/pug-ts"
    );
    this.imports.addLine(
      `* Edit the file ${this.moduleName}.view.template.pug that will generate the ${this.variablesNames.view}.template.ts file automatically`
    );
    this.imports.indent--;
    this.imports.addLine("*/");
    this.imports.addLine(
      `import { VDom, _, DataTypes, TTemplateFunction, TDataTypesFromStructure, TEntityJsonData, VNode, VNodeChildren, VNodeData, VNodeOn, Hooks } from "bonsai";`
    );
    this.imports.addLine("");
    this.imports.addLine(
      `import { ${this.variablesNames.view} } from "./${this.moduleName}.view";`
    );

    this.body.addLine(
      `export const ${this.variablesNames.templateFunctionConst}: TTemplateFunction<${this.variablesNames.view}> = function ${this.variablesNames.templateFunction}(`
    );
    this.body.indent++;
    this.body.addLine(`view: ${this.variablesNames.view},`);
    this.body.addLine(`data: ${this.variablesNames.typedDataTemplate},`);
    // this.body.addLine(
    //   `uiEventsBindings: ${this.variablesNames.view}["TUIEvents"],`
    // );
    // this.body.addLine(
    //   `elementSelector: ${this.variablesNames.view}["elementSelector"]`
    // );
    this.body.indent--;
    this.body.addLine(") {");
    this.body.indent++;
    this.body.addLine("if (!VDom) {");
    this.body.indent++;
    this.body.addLine(`throw "VDom not found.";`);
    this.body.indent--;
    this.body.addLine("}");

    this.body.addLine("const elementSelector = view.elementSelector;");
    this.body.addLine("const uiEventsBindings = view.uiEventBindings;");
    this.body.addLine("const regions = view.regionElements || null;");
    this.body.indent--;
    this.visit(this.ast);

    // write mixins there
    if (this.mixinCompilers.length > 0) {
      const mixinCodes: string[] = [];
      this.mixinCompilers.forEach((mixinCompiler) => {
        // this.body.addLine(mixinCompiler.compile());
        mixinCodes.push(mixinCompiler.compile());
      });
      this.body.addLineAtIndex(
        mixinCodes.join("\n"),
        this.beforeBodyReturnIndex
      );
    }
    this.body.addLine("}");

    this.body.addLine("");
  }

  compileCompositeDataTag() {}

  visitData(node: TPugTagNode) {
    const _dataBlock = node.block as TPugBlockNode;
    const _dataNodes = _dataBlock.nodes;

    if (_dataNodes.length) {
      this.dataStructure.addLine(
        `const ${this.variablesNames.dataStructure} = {`
      );
      this.dataStructure.indent++;

      _dataNodes.forEach((_dataNode, i) => {
        const prop = (_dataNode as TPugTagNode).name;
        const _dataNode_nodes = (_dataNode as TPugTagNode).block.nodes;

        let value: string;
        if (
          _dataNode_nodes.length === 1 &&
          _dataNode_nodes[0].type === "Text"
        ) {
          const content =
            i < _dataNodes.length
              ? `${prop}: DataTypes.${_dataNode_nodes[0].val}(),`
              : `${prop}: DataTypes.${_dataNode_nodes[0].val}()`;
          this.dataStructure.addLine(content);
        } else if (
          _dataNode_nodes[0].type === "Text" &&
          _dataNode_nodes[1] &&
          _dataNode_nodes[1].type === "Tag" &&
          _dataNode_nodes[1].block &&
          _dataNode_nodes[1].block.nodes &&
          _dataNode_nodes[1].block.nodes[0].type === "Text"
        ) {
          this.dataStructure.addLine(
            `${prop}: DataTypes.${_dataNode_nodes[0].val}({`
          );
          this.dataStructure.indent++;
          this.dataStructure.addLine(
            `${_dataNode_nodes[1].name}: DataTypes.${_dataNode_nodes[1].block.nodes[0].val}()`
          );
          this.dataStructure.indent--;
          this.dataStructure.addLine("})");
          let value:
            | string
            | boolean = `DataTypes.${_dataNode_nodes[0].val}({ ${_dataNode_nodes[1].name}: `;
          const _subDataBlock = _dataNode_nodes[1].block;
          const _subDataNodes = _subDataBlock.nodes;
          if (_subDataNodes.length && _subDataNodes[0].type === "Text") {
            value += `DataTypes.${_subDataNodes[0].val} })`;
          } else {
            value = false;
          }
        }
      });
      this.dataStructure.indent--;
      this.dataStructure.addLine("};");
      this.dataStructure.addLine("");
      this.dataStructure.addLine(
        `export type ${this.variablesNames.typedDataStructure} = TDataTypesFromStructure<typeof ${this.variablesNames.dataStructure}>;`
      );
      this.dataStructure.addLine("");
      this.dataStructure.addLine(
        `type ${this.variablesNames.typedDataTemplate} = Required<TEntityJsonData<${this.variablesNames.typedDataStructure}>>`
      );
    }
  }

  // override BaseCompiler.visit()
  visit(node: TPugAnyNode) {
    if (node.type === "Tag" && node.name === "_data") {
      this.visitData(node);
    } else {
      if (!this[`visit${node.type}`]) {
        throw new Error(`Node not handled: ${node.type}`);
      }
      this[`visit${node.type}`](node);
    }
  }

  visitInclude(node: TPugIncludeNode) {
    const block = node.file.ast;
    this.visitBlock(block);
  }

  // override BaseCompiler.visitTag()
  visitTag(node: TPugTagNode | TPugInterpolatedTagNode) {
    const props = this.compileAttrs(node.attrs, node.attributeBlocks);
    const isFirstNode = this.nodeId === 0;

    if (isFirstNode) {
      const isRootTagName = `("${
        (node as TPugTagNode).name
      }" !== elementSelector.tagName)`;
      const idAttribute = props.attrs.id ? `"${props.attrs.id}"` : "undefined";
      const classAttributes = props.attrs.class
        ? JSON.stringify((props.attrs as any).class)
        : `(<any[]>[undefined])`;

      this.body.addLine("if (");
      this.body.indent++;
      this.body.addLine(`${isRootTagName} ||`);
      this.body.addLine(
        `("id" === elementSelector.attr && ${idAttribute} !== elementSelector.value) ||`
      );
      this.body.addLine(
        `("class" === elementSelector.attr) && !${classAttributes}.includes(elementSelector.value)`
      );

      // this.body.addLine(
      //   `("id" === elementSelector.attr && "${
      //     props.attrs ? props.attrs.id : null
      //   }" !== elementSelector.value) ||`
      // );
      // const classes = JSON.stringify((props.attrs as any).class || ["null"]);
      // this.body.addLine(
      //   `("class" === elementSelector.attr) && !${classes}.includes(elementSelector.value)`
      // );
      this.body.indent--;
      this.body.addLine(") {");
      this.body.indent++;
      this.body.addLine(
        `throw "Invalid root element in ${this.variablesNames.templateFunction} function";`
      );
      this.body.indent--;
      this.body.addLine("}");
    }

    const id = this.uid();

    this.body.addLine("");
    this.body.addLine(`const n${id}Child: VNodeChildren = [];`);

    const s = this.parentTagId;
    this.parentTagId = id;
    if (!isNull(node.block)) {
      this.visitBlock(node.block);
    }
    this.body.addLine(`const props${id}: VNodeData = {}`);
    const selectors: {
      selector: string;
      value: string;
      total: string | null;
    }[] = [];
    // const regions: { selector: string; value: string; }[] = [];
    for (const propKey in props) {
      const prop = props[propKey];

      if ("key" === propKey) {
        this.body.addLine(`props${id}.key = "${prop}";`);
      } else if ("attrs" === propKey) {
        if (!isEmpty(prop)) {
          Object.keys(prop).forEach((attr, index) => {
            const value = prop[attr]["val"];
            if (0 === index) {
              this.body.addLine(`props${id}.attrs = {};`);
            }
            switch (attr) {
              case "class":
                if (!prop[attr].interpolate) {
                  this.body.addLine(
                    `props${id}.attrs.class = "${transformClassArray(value)}";`
                  );
                  (value as string[]).forEach((className) => {
                    selectors.push({
                      selector: ".",
                      value: className,
                      total: `.${className}`
                    });
                  });
                } else {
                  this.body.addLine(`props${id}.attrs.class = ${value};`);
                  selectors.push({
                    selector: ".",
                    value,
                    total: null
                  });
                }

                break;
              case "id":
                if (!prop[attr].interpolate) {
                  this.body.addLine(`props${id}.attrs.id = "${value}";`);
                  selectors.push({ selector: "#", value, total: `#${value}` });
                } else {
                  this.body.addLine(`props${id}.attrs.id = ${value};`);
                  selectors.push({ selector: "#", value, total: null });
                }
                break;
              default:
                if (!prop[attr].interpolate) {
                  this.body.addLine(
                    `props${id}.attrs["${attr}"] = "${value}";`
                  );
                  if (/^data-[a-zA-Z]+$/.test(attr)) {
                    selectors.push({
                      selector: attr,
                      value,
                      total: `[${attr}]`
                    });
                  }
                } else {
                  this.body.addLine(`props${id}.attrs["${attr}"] = ${value};`);
                  if (/^data-[a-zA-Z]+$/.test(attr)) {
                    selectors.push({ selector: attr, value, total: null });
                  }
                }
            }
          });
        }
      }
    }
    if (selectors.length) {
      this.body.addLine(`props${id}.on = {}`);
      this.body.addLine(`props${id}.hook = {}`);
      // this.body.addLine(`const selectors${id} = ${JSON.stringify(selectors)}`);
      selectors.forEach((selector, i) => {
        if (!isNull(selector.total)) {
          this.body.addLine(
            `const uiEventBinding_${id}_${i} = "${selector.total}";`
          );
        } else {
          this.body.addLine(
            `const uiEventBinding_${id}_${i} = ${selector.value};`
          );
        }
        this.body.addLine(
          `if (Object.keys(uiEventsBindings).includes(uiEventBinding_${id}_${i})) {`
        );
        this.body.indent++;
        // this.body.addLine(`const test__${id} = uiEventsBindings["${selector}"]`);
        this.body.addLine(
          `uiEventsBindings["${selector.total}"].forEach((eventBinding) => {`
        );
        this.body.indent++;
        this.body.addLine(
          `(props${id}.on as VNodeOn)[eventBinding.event] = eventBinding.callback;`
        );
        this.body.indent--;
        this.body.addLine("});");
        this.body.indent--;
        this.body.addLine("}");

        this.body.addLine("if (!_.isNull(regions)) {");
        this.body.indent++;
        this.body.addLine(
          "Object.values(regions as any).forEach((regionElement: any) => {"
        );
        this.body.indent++;
        this.body.addLine(
          `if (regionElement.selector === "${selector.selector}" && regionElement.value === "${selector.value}" ) {`
        );
        this.body.indent++;
        this.body.addLine(
          `(props${id}.hook as Hooks).insert = regionElement.insertCallback;`
        );
        this.body.addLine(
          `(props${id}.hook as Hooks).remove = regionElement.removeCallback;`
        );
        this.body.indent--;
        this.body.addLine("}");
        this.body.indent--;
        this.body.addLine("});");
        this.body.indent--;
        this.body.addLine("}");
      });
    }

    if (isFirstNode) {
      this.body.addLine(
        `return VDom.h(${
          (node as TPugTagNode).name
            ? `'${(node as TPugTagNode).name}'`
            : `${(node as TPugInterpolatedTagNode).expr}`
        }, props${id}, n${id}Child);`
      );
      this.beforeBodyReturnIndex = this.body.getCurrentIndex();
    } else {
      this.body.addLine(
        `var n${id} = VDom.h(${
          (node as TPugTagNode).name
            ? `'${(node as TPugTagNode).name}'`
            : `${(node as TPugInterpolatedTagNode).expr}`
        }, props${id}, n${id}Child);`
      );
      this.parentTagId = s;
      this.body.addLine(`n${s}Child.push(n${id});`);
    }
  }

  visitMixin(node: TPugMixinNode) {
    const mixinName = node.name;

    var s = this.parentTagId;
    // if node.call === mixin is executed via +mixin_name(params)
    if (node.call) {
      if (node.block) {
        // the call mixin define a block
        const id = this.uid();
        this.parentTagId = id;
        this.body.indent++;
        this.body.addLine(`const n${id}Child = []`);
        this.visitBlock(node.block);
        var args = node.args ? `${node.args}, n${id}Child` : `n${id}Child`;
        this.body.addLine(`n${s}Child.push(${node.name}(${args}));`);
        this.body.indent--;
        this.parentTagId = s;
      } else {
        this.body.addLine(`n${s}Child.push(${node.name}(${node.args})[0]);`);
      }
      return;
    } else {
      // mixinCompiler.
      let mixinCompiler = this.mixinCompilers.find((mixin) => {
        return mixinName === mixin.name;
      });
      if (mixinCompiler === undefined) {
        this.mixinCompilers.push(
          new MixinCompiler(node.block, mixinName, this.body.indent)
        );
        mixinCompiler = this.mixinCompilers.find((mixin) => {
          return mixinName === mixin.name;
        });
      }
      const id = mixinCompiler.uid(); //increment mixinCompiler.nodeId;
      mixinCompiler.parentTagId = id;
      const nodeArgs = node.args;
      let defNodeArgs: string = "";
      if (!isNull(nodeArgs)) {
        nodeArgs.split(",").forEach((nodeArg, index) => {
          if (index > 0) {
            defNodeArgs += ", ";
          }
          defNodeArgs += `${nodeArg}: any`;
        });
      }
      var args = node.args ? `${defNodeArgs}, __block?: any` : `__block?: any`;
      mixinCompiler.body.addLine(`function ${node.name}(${args}) {`);
      mixinCompiler.body.indent++;
      mixinCompiler.body.addLine(`const n${id}Child: VNodeChildren = []`);
      if (node.block) {
        mixinCompiler.visitBlock(node.block);
      }
      mixinCompiler.body.addLine(`return n${id}Child`);
      mixinCompiler.body.indent--;
      mixinCompiler.parentTagId = s;
      mixinCompiler.body.addLine(`}`);
      // this.body.addLine(mixinCompiler.compile());
    }
  }

  visitMixinBlock(node) {
    this.body.addLine(`n${this.parentTagId}Child.push(__block);`);
  }

  visitCase(node: TPugCaseNode) {
    this.body.addLine(`switch(${node.expr}) {`);
    node.block.nodes.forEach((_case, index) => {
      this.body.indent++;
      this.visit(_case);
      this.body.indent--;
    });
    this.body.addLine(`}`);
  }

  visitWhen(node: TPugWhenNode) {
    if (node.expr === "default") {
      this.body.addLine(`default:`);
    } else {
      this.body.addLine(`case ${node.expr}:`);
    }
    this.body.indent++;
    if (node.block) {
      this.visit(node.block);
    }
    this.body.addLine(`break;`);
    this.body.indent--;
  }
}
