/**
 * Bundle des fichiers de d√©finition TypeScript (.d.ts) pour les biblioth√®ques Bonsai
 *
 * Ce module permet de g√©n√©rer un fichier .d.ts unique qui regroupe toutes les d√©finitions
 * de types d'une biblioth√®que externe (package cible) dans un namespace sp√©cifique.
 * Le namespace est d√©fini par la propri√©t√© 'namespace' du package source.
 */

import * as path from "node:path";
import fileSystem from "fs-extra";
import { Project, SyntaxKind, SourceFile, Node, Statement } from "ts-morph";
import { PathManager } from "@build/core/path-manager.class";
import { TPackage } from "@lib/build/build.type";
import { Path } from "glob";

// Type pour un namespace ts-morph
type NamespaceDeclaration = Node;

/**
 * G√©n√®re un fichier bundle de d√©finitions TypeScript (.d.ts) pour un package
 * en regroupant toutes les d√©finitions de types √† plat dans un objet export√© unique.
 *
 * @param pkg - TPackage repr√©sentant le package source
 */
async function generateBundledDts(pkg: TPackage): Promise<void> {
  const namespaceName = pkg.namespace;
  if (!namespaceName) {
    throw new Error(
      `Le package ${pkg.name} n'a pas de namespace d√©fini dans son package.json`
    );
  }
  console.log(
    `üîÑ Traitement de la biblioth√®que ${pkg.name} avec le namespace ${namespaceName}`
  );
  const project = new Project({
    compilerOptions: {
      declaration: true,
      emitDeclarationOnly: true,
      skipLibCheck: true
    }
  });
  const dtsFiles = getAllDtsFiles(pkg);
  if (dtsFiles.length === 0) {
    throw new Error(`Aucun fichier .d.ts trouv√© pour ${pkg.name}`);
  }
  project.addSourceFilesAtPaths(dtsFiles);
  const outputFilePath = pkg.outDtsFile;
  console.log(`üìù Cr√©ation du fichier de sortie: ${outputFilePath}`);
  // Set global pour √©viter les doublons de d√©claration
  const declaredNames = new Set<string>();
  const exportNames = new Set<string>();
  const typeDeclarations: string[] = [];
  const valueDeclarations: string[] = [];
  for (const sourceFile of project.getSourceFiles()) {
    for (const statement of sourceFile.getStatements()) {
      // Types
      if (
        Node.isInterfaceDeclaration(statement) ||
        Node.isTypeAliasDeclaration(statement) ||
        Node.isEnumDeclaration(statement) ||
        Node.isClassDeclaration(statement)
      ) {
        if (statement.getName) {
          const name = statement.getName();
          if (name && !declaredNames.has(name)) {
            typeDeclarations.push(statement.getText());
            declaredNames.add(name);
            if (statement.isExported && statement.isExported()) {
              exportNames.add(name);
            }
          }
        }
      }
      // Fonctions export√©es
      if (Node.isFunctionDeclaration(statement)) {
        if (statement.getName) {
          const name = statement.getName();
          if (name && !declaredNames.has(name)) {
            valueDeclarations.push(statement.getText());
            declaredNames.add(name);
            if (statement.isExported && statement.isExported()) {
              exportNames.add(name);
            }
          }
        }
      }
      // Variables export√©es
      if (Node.isVariableStatement(statement)) {
        const declList = statement.getDeclarationList();
        for (const decl of declList.getDeclarations()) {
          if (decl.getName) {
            const name = decl.getName();
            if (name && !declaredNames.has(name)) {
              valueDeclarations.push(statement.getText());
              declaredNames.add(name);
              if (decl.isExported && decl.isExported()) {
                exportNames.add(name);
              }
            }
          }
        }
      }
    }
  }
  // G√©n√©rer le bloc namespace RXJS
  const cleanDeclaration = (line: string) =>
    line
      .replace(/^\s*export\s+(declare\s+)?/gm, "")
      .replace(/^\s*declare\s+/gm, "");
  const namespaceBody = [...typeDeclarations, ...valueDeclarations]
    .map(cleanDeclaration)
    .filter(Boolean)
    .join("\n\n");
  const namespaceBlock = `declare namespace ${namespaceName} {\n${namespaceBody
    .split("\n")
    .map((l) => (l ? "  " + l : ""))
    .join("\n")}\n}`;
  // Nettoyer les imports relatifs restants (../ ou ./)
  function removeRelativeImports(code: string): string {
    return code.replace(
      /^\s*import[^;]+from\s+['\"](\.\.?\/[^'\"]+)['\"];?\s*$/gm,
      ""
    );
  }
  // Remplace les r√©f√©rences import√©es par leur nom local (g√©n√©rique)
  function fixInlineTypeImports(code: string): string {
    // Remplace import("...").Type par Type, pour tous les chemins
    return code.replace(/import\(["'][^"']+["']\)\.(\w+)/g, "$1");
  }
  // G√©n√©rer le contenu final
  const header = `/**\n * Types pour ${pkg.name}\n * G√©n√©r√©s automatiquement - NE PAS MODIFIER\n */\n`;
  let content = [header, namespaceBlock, `export { ${namespaceName} };`].join(
    "\n\n"
  );
  content = removeRelativeImports(content);
  content = fixInlineTypeImports(content);
  // √âcrire le fichier de sortie
  await fileSystem.outputFile(outputFilePath, content);
  console.log(`üíæ Fichier bundle sauvegard√©: ${outputFilePath}`);
}

/**
 * Explore r√©cursivement les exports d'un fichier pour extraire toutes les d√©clarations de types
 *
 * @param sourceFile - Fichier source √† explorer
 * @param project - Projet TS-Morph
 * @param processedFiles - Fichiers d√©j√† trait√©s pour √©viter les boucles infinies
 * @returns Un tableau des d√©clarations √† ajouter
 */
function extractDeclarationsRecursively(
  sourceFile: SourceFile,
  project: Project,
  processedFiles: Set<string> = new Set()
): Statement[] {
  const filePath = sourceFile.getFilePath();

  // √âviter les boucles infinies
  if (processedFiles.has(filePath)) {
    return [];
  }

  // console.log(`üîÑ Exploration r√©cursive des exports de: ${filePath}`);
  processedFiles.add(filePath);

  // Collecter toutes les d√©clarations locales
  const declarations: Statement[] = [...sourceFile.getStatements()];

  // Chercher les d√©clarations d'export depuis d'autres modules
  const exportDeclarations = sourceFile.getExportDeclarations();

  for (const exportDecl of exportDeclarations) {
    try {
      const moduleSpecifier = exportDecl.getModuleSpecifierValue();
      if (!moduleSpecifier) continue;

      // console.log(`üì¶ Export trouv√© depuis le module: ${moduleSpecifier}`);

      // Tenter de r√©soudre le fichier source du module export√©
      try {
        const resolvedSourceFile = exportDecl.getModuleSpecifierSourceFile();

        if (resolvedSourceFile) {
          // console.log(`‚úÖ Module r√©solu: ${resolvedSourceFile.getFilePath()}`);

          // Extraire r√©cursivement les d√©clarations du module import√©
          const importedDeclarations = extractDeclarationsRecursively(
            resolvedSourceFile,
            project,
            processedFiles
          );

          // Ajouter les d√©clarations import√©es √† notre collection
          declarations.push(...importedDeclarations);
        } else {
          console.log(
            `‚ö†Ô∏è Impossible de r√©soudre le module: ${moduleSpecifier}`
          );
        }
      } catch (error) {
        console.warn(
          `‚ö†Ô∏è Erreur lors de la r√©solution du module ${moduleSpecifier}:`,
          error
        );
      }
    } catch (error) {
      console.warn(
        `‚ö†Ô∏è Erreur lors du traitement d'une d√©claration d'export:`,
        error
      );
    }
  }

  return declarations;
}

/**
 * Copie les d√©clarations d'un fichier source vers un namespace cible
 * en √©vitant les doublons.
 *
 * @param sourceFile - Fichier source contenant les d√©clarations
 * @param namespace - Namespace cible o√π ajouter les d√©clarations
 * @param addedDeclarations - Ensemble des d√©clarations d√©j√† ajout√©es (pour √©viter les doublons)
 * @returns Nombre de d√©clarations ajout√©es
 */
function copyDeclarationsToNamespace(
  sourceFile: SourceFile,
  namespace: Node,
  addedDeclarations: Set<string>
): number {
  // console.log(
  //   `üîç Extraction des d√©clarations du fichier: ${sourceFile.getFilePath()}`
  // );

  // R√©cup√©rer toutes les d√©clarations du fichier source en explorant r√©cursivement les exports
  const project = sourceFile.getProject();
  const declarations = extractDeclarationsRecursively(sourceFile, project);
  // console.log(
  //   `üìä Nombre de d√©clarations trouv√©es (avec r√©cursion): ${declarations.length}`
  // );

  let addedCount = 0;

  // Types de d√©clarations √† inclure dans le namespace
  const relevantDeclarationKinds = [
    SyntaxKind.InterfaceDeclaration,
    SyntaxKind.TypeAliasDeclaration,
    SyntaxKind.EnumDeclaration,
    SyntaxKind.ClassDeclaration,
    SyntaxKind.FunctionDeclaration,
    SyntaxKind.VariableStatement,
    SyntaxKind.ModuleDeclaration
  ];

  // R√©cup√©rer le corps du namespace
  // Approche s√©curis√©e pour r√©cup√©rer le corps du namespace
  let namespaceBody: any;
  try {
    // Acc√®s s√©curis√© en v√©rifiant chaque √©tape
    if (
      namespace.getKind &&
      namespace.getKind() === SyntaxKind.ModuleDeclaration
    ) {
      // Pour les ModuleDeclaration (qui repr√©sentent les namespaces dans TS)
      const moduleDecl = namespace as any;
      if (moduleDecl.getBody) {
        namespaceBody = moduleDecl.getBody();
      }
    } else {
      // Fallback - essayer directement getBody() si disponible
      // @ts-ignore - Acc√©der au corps du namespace qui est de type Block
      namespaceBody = namespace.getBody && namespace.getBody();
    }
  } catch (error) {
    console.error("Erreur lors de l'acc√®s au corps du namespace:", error);
  }

  if (!namespaceBody) {
    // Si nous n'avons pas pu obtenir le corps via getBody, essayons une approche alternative
    try {
      // Extraire le corps du namespace en analysant la structure
      const children = namespace.getChildren && namespace.getChildren();
      if (children && children.length > 0) {
        // Le dernier enfant est g√©n√©ralement le bloc de code
        const lastChild = children[children.length - 1];
        if (
          lastChild &&
          lastChild.getKind &&
          lastChild.getKind() === SyntaxKind.Block
        ) {
          namespaceBody = lastChild;
        }
      }
    } catch (error) {
      console.error(
        "Erreur lors de l'extraction du corps du namespace via les enfants:",
        error
      );
    }
  }

  if (!namespaceBody) {
    throw new Error(
      `Impossible de r√©cup√©rer le corps du namespace pour y ajouter des d√©clarations`
    );
  }

  // Extraire √©galement les importations locales pour les transformer en d√©clarations
  const importMap = new Map<string, string>();
  for (const declaration of declarations) {
    if (declaration.getKind() === SyntaxKind.ImportDeclaration) {
      try {
        // @ts-ignore - Acc√©der aux propri√©t√©s d'ImportDeclaration
        const importClause = declaration.getImportClause();
        // @ts-ignore - Acc√©der aux propri√©t√©s de ModuleSpecifier
        const moduleSpecifier = declaration.getModuleSpecifierValue();

        if (importClause && moduleSpecifier) {
          // Ignorer les importations externes (commen√ßant par des lettres)
          if (
            !moduleSpecifier.startsWith(".") &&
            !moduleSpecifier.startsWith("/")
          ) {
            continue;
          }

          // @ts-ignore - Acc√©der aux propri√©t√©s de NamedImports
          const namedImports = importClause.getNamedImports();
          if (namedImports && namedImports.length > 0) {
            for (const namedImport of namedImports) {
              // @ts-ignore - Acc√©der au nom de l'importation
              const importName = namedImport.getName();
              importMap.set(importName, moduleSpecifier);
            }
          }

          // @ts-ignore - Acc√©der √† DefaultImport
          const defaultImport = importClause.getDefaultImport();
          if (defaultImport) {
            // @ts-ignore - Acc√©der au nom de l'importation par d√©faut
            const defaultName = defaultImport.getText();
            importMap.set(defaultName, moduleSpecifier);
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Erreur lors de l'analyse de l'importation:`, error);
      }
    }
  }

  for (const declaration of declarations) {
    // Ignorer explicitement les d√©clarations d'importation
    if (declaration.getKind() === SyntaxKind.ImportDeclaration) {
      // console.log(`üîÑ Ignor√©: D√©claration d'importation`);
      continue;
    }

    // console.log(
    //   `üîç Analyse de la d√©claration de type: ${
    //     SyntaxKind[declaration.getKind()]
    //   }`
    // );
    // console.log(
    //   `üìù Contenu de la d√©claration:\n${declaration.getText().slice(0, 200)}${
    //     declaration.getText().length > 200 ? "..." : ""
    //   }`
    // );

    // V√©rifier si la d√©claration est d'un type pertinent
    if (relevantDeclarationKinds.includes(declaration.getKind())) {
      // Obtenir le nom de la d√©claration pour √©viter les doublons
      let declarationName = "";
      try {
        // Pour les d√©clarations nomm√©es, essayer d'obtenir le nom
        if (
          declaration.getKind() === SyntaxKind.InterfaceDeclaration ||
          declaration.getKind() === SyntaxKind.TypeAliasDeclaration ||
          declaration.getKind() === SyntaxKind.EnumDeclaration ||
          declaration.getKind() === SyntaxKind.ClassDeclaration ||
          declaration.getKind() === SyntaxKind.FunctionDeclaration
        ) {
          // @ts-ignore - Nous savons que ces d√©clarations ont un nom
          declarationName = declaration.getName();
        } else if (declaration.getKind() === SyntaxKind.VariableStatement) {
          // Pour les d√©clarations de variables, extraire les noms des variables
          try {
            // @ts-ignore - Acc√©der aux d√©clarations de variables
            const variableDeclaration = declaration as any;
            if (
              variableDeclaration.getDeclarationList &&
              typeof variableDeclaration.getDeclarationList === "function"
            ) {
              const declarationList = variableDeclaration.getDeclarationList();
              if (declarationList && declarationList.getDeclarations) {
                const declarations = declarationList.getDeclarations();
                if (declarations.length > 0 && declarations[0].getName) {
                  declarationName = declarations[0].getName();
                }
              }
            }
          } catch (error) {
            console.warn(
              "Erreur lors de l'extraction du nom de variable:",
              error
            );
            declarationName = declaration.getText().slice(0, 100);
          }
        } else {
          // Utiliser un hash du contenu pour les autres d√©clarations
          declarationName = declaration.getText().slice(0, 100); // Limiter la longueur
        }
      } catch {
        // Fallback si getName() n'est pas disponible
        declarationName = declaration.getText().slice(0, 100);
      }

      // V√©rifier si la d√©claration a d√©j√† √©t√© ajout√©e
      if (declarationName && addedDeclarations.has(declarationName)) {
        continue; // Ignorer les d√©clarations d√©j√† ajout√©es
      }

      // Ajouter au set pour √©viter les doublons
      if (declarationName) {
        addedDeclarations.add(declarationName);
      }

      // R√©cup√©rer le code de la d√©claration et l'ajouter au corps du namespace
      let text = declaration.getText();

      // Remplacer les r√©f√©rences aux types import√©s par leurs √©quivalents complets
      for (const [importName, modulePath] of importMap.entries()) {
        const regex = new RegExp(`\\b${importName}\\b(?!\\.)`);
        if (regex.test(text)) {
          // console.log(
          //   `üîÑ R√©solution de la r√©f√©rence: ${importName} -> ${modulePath}`
          // );
        }
      }

      try {
        // Supprimer les pr√©fixes export et export declare
        const cleanedText = text.replace(/^export\s+(declare\s+)?/gm, "");

        // G√©rer le cas des d√©clarations vides ou invalides
        if (!cleanedText.trim()) {
          // console.log(`‚ö†Ô∏è D√©claration vide ignor√©e`);
          continue;
        }

        // V√©rifier si la d√©claration contient des √©l√©ments d'it√©rateur qui peuvent causer des erreurs
        const hasIteratorSyntax =
          /\s+next\(\s*\)/.test(cleanedText) ||
          /\s+Symbol\.iterator\s*\(/.test(cleanedText);

        // Pour les d√©clarations contenant des it√©rateurs (comme dans RxJS), utiliser une approche alternative
        if (hasIteratorSyntax) {
          // console.log(
          //   `üîÑ Utilisation de l'approche alternative pour une d√©claration d'it√©rateur`
          // );

          try {
            // Approche 1: Tentative d'ajout direct avec surveillance des erreurs
            try {
              namespaceBody.addStatements(cleanedText);
              // console.log(
              //   `‚úì D√©claration d'it√©rateur ajout√©e via addStatements: ${declarationName.substring(
              //     0,
              //     30
              //   )}...`
              // );
              addedCount++;
            } catch (addError) {
              console.warn(
                `‚ö†Ô∏è Erreur lors de l'ajout direct de la d√©claration d'it√©rateur: ${addError.message}. Tentative d'approche alternative...`
              );

              // Approche 2: Modification du texte du namespace (plus s√©curis√©e)
              // R√©cup√©rer le texte du namespace
              const namespaceText = namespace.getText();
              if (!namespaceText) {
                throw new Error(
                  "Impossible de r√©cup√©rer le texte du namespace"
                );
              }

              // Trouver la position juste avant l'accolade fermante
              const insertPosition = namespaceText.lastIndexOf("}");
              if (insertPosition <= 0) {
                throw new Error(
                  "Structure de namespace invalide - accolade fermante non trouv√©e"
                );
              }

              // Construire le nouveau texte du namespace
              const newText =
                namespaceText.substring(0, insertPosition) +
                "\n  " +
                cleanedText.replace(/\n/g, "\n  ") +
                "\n" +
                namespaceText.substring(insertPosition);

              // V√©rifier que le nouveau texte est valide
              if (!newText || newText === namespaceText) {
                throw new Error(
                  "√âchec de la g√©n√©ration du nouveau texte pour le namespace"
                );
              }

              // Utiliser une approche s√©curis√©e pour remplacer le texte
              try {
                namespace.replaceWithText(newText);
                // console.log(
                //   `‚úì D√©claration d'it√©rateur ajout√©e via replaceWithText: ${declarationName.substring(
                //     0,
                //     30
                //   )}...`
                // );
                addedCount++;
              } catch (replaceError) {
                throw new Error(
                  `√âchec du remplacement du texte: ${replaceError.message}`
                );
              }
            }
          } catch (error) {
            // Approche 3: Ajouter la d√©claration en tant que commentaire si tout √©choue
            console.warn(
              `‚ö†Ô∏è √âchec de toutes les tentatives d'ajout de la d√©claration d'it√©rateur. Ajout en commentaire pour r√©f√©rence: ${error.message}`
            );

            try {
              const commentText = `/* D√©claration probl√©matique avec it√©rateur - ajout√©e en commentaire:
${cleanedText}
*/`;
              namespaceBody.addStatements(commentText);
              // console.log(
              //   `‚úì D√©claration d'it√©rateur ajout√©e en commentaire: ${declarationName.substring(
              //     0,
              //     30
              //   )}...`
              // );
              // Ne pas incr√©menter addedCount car nous n'avons pas vraiment ajout√© la d√©claration
            } catch (commentError) {
              console.error(
                `‚ùå Impossible d'ajouter m√™me en commentaire: ${commentError.message}. La d√©claration sera ignor√©e.`
              );
            }
          }
        } else {
          // Approche standard pour les d√©clarations normales
          namespaceBody.addStatements(cleanedText);
          // console.log(
          //   `‚úì D√©claration ajout√©e: ${declarationName.substring(0, 50)}${
          //     declarationName.length > 50 ? "..." : ""
          //   }`
          // );
          addedCount++;
        }
      } catch (error) {
        console.warn(
          `‚ö†Ô∏è Erreur lors de l'ajout de la d√©claration "${declarationName.substring(
            0,
            50
          )}...": ${error.message}`
        );

        // Approche de secours en cas d'erreur
        try {
          console.log("Tentative de r√©cup√©ration suite √† l'erreur...");

          // Approche 1: Ajout comme commentaire
          try {
            const commentText = `/* D√©claration probl√©matique - ajout√©e en commentaire pour r√©f√©rence:
${text.replace(/^export\s+(declare\s+)?/gm, "")}
*/`;

            // Essayer d'ajouter directement comme commentaire
            namespaceBody.addStatements(commentText);
            console.log(
              `‚úì D√©claration ajout√©e en commentaire: ${declarationName.substring(
                0,
                30
              )}...`
            );
            // Ne pas incr√©menter addedCount car c'est juste un commentaire
          } catch (commentError) {
            console.warn(
              `‚ö†Ô∏è √âchec de l'ajout en commentaire: ${commentError.message}`
            );

            // Approche 2: Modification manuelle du texte (comme dernier recours)
            try {
              // R√©cup√©rer le texte du namespace de mani√®re s√©curis√©e
              let namespaceText: string | undefined;
              try {
                namespaceText = namespace.getText();
              } catch (textError) {
                console.warn(
                  `‚ö†Ô∏è Impossible de r√©cup√©rer le texte du namespace: ${textError.message}`
                );

                // Si nous ne pouvons pas obtenir le texte, abandonner cette approche
                throw new Error(
                  "Impossible de r√©cup√©rer le texte du namespace"
                );
              }

              if (!namespaceText) {
                throw new Error("Le texte du namespace est vide ou ind√©fini");
              }

              // Trouver la position juste avant l'accolade fermante
              const insertPosition = namespaceText.lastIndexOf("}");
              if (insertPosition <= 0) {
                throw new Error(
                  "Accolade fermante non trouv√©e dans le namespace"
                );
              }

              // Cr√©er un commentaire s√©curis√© pour √©viter tout probl√®me syntaxique
              const safeComment = `// D√âCLARATION PROBL√âMATIQUE (ajout√©e comme commentaire)
  // Nom original: ${declarationName.substring(0, 30)}...
  // Cette d√©claration a √©t√© comment√©e pour √©viter les erreurs de compilation
  `;

              // Construire le nouveau texte avec le commentaire
              const newText =
                namespaceText.substring(0, insertPosition) +
                "\n  " +
                safeComment +
                "\n" +
                namespaceText.substring(insertPosition);

              // Tenter de remplacer le texte
              namespace.replaceWithText(newText);
              console.log(
                `‚úì Commentaire de s√©curit√© ajout√© pour: ${declarationName.substring(
                  0,
                  30
                )}...`
              );
            } catch (finalError) {
              console.error(
                `‚ùå Toutes les tentatives de r√©cup√©ration ont √©chou√©: ${finalError.message}`
              );
              console.warn(
                `‚ö†Ô∏è La d√©claration "${declarationName.substring(
                  0,
                  30
                )}..." sera ignor√©e compl√®tement`
              );
            }
          }
        } catch (alternativeError) {
          console.error(`‚ùå √âchec de la m√©thode de secours:`, alternativeError);
          console.warn(
            `‚ö†Ô∏è La d√©claration sera ignor√©e pour √©viter l'√©chec complet du build`
          );
        }
      }
    }
  }

  return addedCount;
}

/**
 * Collecte r√©cursivement tous les fichiers .d.ts dans un dossier et ses sous-dossiers.
 * R√©sout √©galement les r√©f√©rences (<reference path="...">) dans les fichiers.
 *
 * @param dir - Dossier √† parcourir
 * @param dtsFiles - Tableau o√π stocker les chemins des fichiers trouv√©s
 * @param ignoreDirs - Dossiers √† ignorer lors de la recherche
 * @param processedFiles - Ensemble des fichiers d√©j√† trait√©s (pour √©viter les doublons)
 */
function collectDtsFiles(
  dir: string,
  dtsFiles: string[],
  ignoreDirs: string[] = [".git"],
  processedFiles: Set<string> = new Set()
): void {
  // console.log(`üìÇ Exploration du r√©pertoire: ${dir}`);

  if (!fileSystem.existsSync(dir)) {
    console.log(`‚ö†Ô∏è Le r√©pertoire n'existe pas: ${dir}`);
    return;
  }

  try {
    const files = fileSystem.readdirSync(dir);

    for (const file of files) {
      const filePath = path.join(dir, file);

      try {
        const stat = fileSystem.statSync(filePath);

        if (stat.isDirectory()) {
          // Ignorer certains dossiers non pertinents
          if (!ignoreDirs.includes(file)) {
            collectDtsFiles(filePath, dtsFiles, ignoreDirs, processedFiles);
          }
        } else if (file.endsWith(".d.ts") && !file.endsWith(".min.d.ts")) {
          // Ignorer les fichiers minifi√©s
          if (!processedFiles.has(filePath)) {
            dtsFiles.push(filePath);
            processedFiles.add(filePath);
            // console.log(`üìÑ Fichier .d.ts trouv√©: ${filePath}`);

            // Afficher les premi√®res lignes du fichier pour d√©bug
            try {
              const content = fileSystem.readFileSync(filePath, "utf-8");
              const firstLines = content.split("\n").slice(0, 10).join("\n");
              // console.log(
              //   `üìù Aper√ßu du fichier ${filePath}:\n${firstLines}\n[...]`
              // );
            } catch (error) {
              console.warn(
                `‚ö†Ô∏è Impossible de lire le contenu de ${filePath}:`,
                error
              );
            }

            // Traiter les r√©f√©rences dans le fichier
            try {
              const content = fileSystem.readFileSync(filePath, "utf-8");
              const referenceRegex =
                /\/\/\/\s*<reference\s+path\s*=\s*["']([^"']+)["']\s*\/>/g;
              let match;

              while ((match = referenceRegex.exec(content)) !== null) {
                const referencePath = match[1];
                const absoluteReferencePath = path.resolve(
                  path.dirname(filePath),
                  referencePath
                );

                if (
                  fileSystem.existsSync(absoluteReferencePath) &&
                  !processedFiles.has(absoluteReferencePath)
                ) {
                  dtsFiles.push(absoluteReferencePath);
                  processedFiles.add(absoluteReferencePath);
                  // console.log(
                  //   `üìÑ Fichier r√©f√©renc√© trouv√©: ${absoluteReferencePath}`
                  // );

                  // Si c'est un dossier, collecter tous les fichiers .d.ts
                  if (
                    fileSystem.statSync(absoluteReferencePath).isDirectory()
                  ) {
                    collectDtsFiles(
                      absoluteReferencePath,
                      dtsFiles,
                      ignoreDirs,
                      processedFiles
                    );
                  }
                }
              }
            } catch (error) {
              console.warn(
                `‚ö†Ô∏è Erreur lors de la lecture des r√©f√©rences dans ${filePath}:`,
                error
              );
            }
          }
        }
      } catch (error) {
        console.warn(`‚ö†Ô∏è Erreur lors de l'acc√®s √† ${filePath}:`, error);
      }
    }
  } catch (error) {
    console.warn(`‚ö†Ô∏è Erreur lors de la lecture du dossier ${dir}:`, error);
  }
}

/**
 * R√©cup√®re tous les fichiers .d.ts de la librairie cible.
 * La librairie cible est d√©termin√©e en analysant les importations dans le fichier source.
 *
 * @param pkg - TPackage repr√©sentant le package source
 * @returns Liste des chemins absolus vers les fichiers .d.ts
 */
function getAllDtsFiles(pkg: TPackage): string[] {
  const pathManager = PathManager.me();
  // R√©cup√©rer le nom du package source
  const packageName = pkg.name;

  // Lire le contenu du fichier source pour identifier la librairie cible
  const srcContent = fileSystem.readFileSync(pkg.srcFile, "utf-8");

  // Analyse pour trouver toutes les importations
  const importMatches = srcContent.match(/from ['"]([^'"]+)['"]/g);
  if (!importMatches || importMatches.length === 0) {
    throw new Error(
      `Impossible de d√©terminer la librairie cible dans ${pkg.srcFile}`
    );
  }

  // Extraire les noms de toutes les librairies import√©es et leurs sous-packages
  const targetLibraries = new Set<string>();
  const subPackages = new Map<string, Set<string>>();

  for (const importMatch of importMatches) {
    const match = importMatch.match(/from ['"]([^'"]+)['"]/);
    if (match && match[1]) {
      const libraryPath = match[1];
      const pathParts = libraryPath.split("/");
      const mainLibrary = pathParts[0];

      // Ajouter la biblioth√®que principale
      targetLibraries.add(mainLibrary);

      // Si c'est un sous-package (comme rxjs/operators), l'enregistrer
      if (pathParts.length > 1) {
        if (!subPackages.has(mainLibrary)) {
          subPackages.set(mainLibrary, new Set<string>());
        }
        subPackages.get(mainLibrary)!.add(libraryPath);
      }
    }
  }
  if (targetLibraries.size === 0) {
    throw new Error(
      `Impossible de d√©terminer la librairie cible dans ${pkg.srcFile}`
    );
  }

  console.log(
    `üì¶ Librairies cibles identifi√©es: ${Array.from(targetLibraries).join(
      ", "
    )}`
  );

  // Ajouter tous les sous-packages aux cibles √† traiter
  for (const [mainLib, subPkgs] of subPackages.entries()) {
    console.log(
      `üì¶ Sous-packages de ${mainLib} d√©tect√©s: ${Array.from(subPkgs).join(
        ", "
      )}`
    );
    // Ajouter chaque sous-package √† la liste des biblioth√®ques cibles
    subPkgs.forEach((subPkg) => targetLibraries.add(subPkg));
  }

  // Collecter les fichiers .d.ts
  const dtsFiles: string[] = [];

  // const nodeModulesPath = path.join(buildStoreConfig.rootPath, "node_modules");
  // with PathManager
  const nodeModulesPath = path.join(pathManager.rootPath, "node_modules");

  // Traiter chaque librairie cible
  for (const targetLibrary of targetLibraries) {
    console.log(`üîç Recherche des fichiers .d.ts pour ${targetLibrary}...`);

    // Recherche dans PNPM puis dans le node_modules standard
    const basePackageName = targetLibrary.split("/")[0]; // Prendre la partie avant le premier /

    // Rechercher d'abord dans la structure PNPM
    const pnpmDir = path.join(nodeModulesPath, ".pnpm");
    let libraryPath = "";

    if (fileSystem.existsSync(pnpmDir)) {
      try {
        // Trouver le dossier du package dans la structure PNPM
        const possibleDirs = fileSystem
          .readdirSync(pnpmDir)
          .filter((dir) => dir.startsWith(`${basePackageName}@`));

        if (possibleDirs.length > 0) {
          // console.log(`üì¶ Package PNPM trouv√©: ${possibleDirs[0]}`);

          // Pour le package principal (par exemple 'rxjs')
          if (targetLibrary === basePackageName) {
            libraryPath = path.join(
              pnpmDir,
              possibleDirs[0],
              "node_modules",
              basePackageName
            );
          }
          // Pour les sous-packages (par exemple 'rxjs/operators')
          else if (targetLibrary.includes("/")) {
            // Construire le chemin vers le module dans .pnpm
            const subPackagePath = targetLibrary.substring(
              targetLibrary.indexOf("/") + 1
            );
            libraryPath = path.join(
              pnpmDir,
              possibleDirs[0],
              "node_modules",
              basePackageName
            );
          }
        }
      } catch (error) {
        console.warn(
          `‚ö†Ô∏è Erreur lors de la recherche PNPM pour ${targetLibrary}:`,
          error
        );
      }
    }

    // Si PNPM a √©chou√©, essayer dans node_modules standard
    if (!libraryPath || !fileSystem.existsSync(libraryPath)) {
      const standardPath = path.join(nodeModulesPath, targetLibrary);
      if (fileSystem.existsSync(standardPath)) {
        libraryPath = standardPath;
        console.log(
          `üì¶ Package trouv√© dans node_modules standard: ${libraryPath}`
        );
      }
    }

    if (!libraryPath || !fileSystem.existsSync(libraryPath)) {
      console.warn(`‚ö†Ô∏è Impossible de trouver le package ${targetLibrary}`);
      continue;
    }

    // Lire le package.json pour trouver le chemin des types
    try {
      const packageJsonPath = path.join(libraryPath, "package.json");
      if (fileSystem.existsSync(packageJsonPath)) {
        const packageJson = JSON.parse(
          fileSystem.readFileSync(packageJsonPath, "utf-8")
        );
        const typesPath = packageJson.types || packageJson.typings;

        if (typesPath) {
          console.log(
            `üìÑ Chemin des types d√©fini dans package.json: ${typesPath}`
          );
          const absoluteTypesPath = path.join(libraryPath, typesPath);

          // V√©rifier si le chemin des types existe
          if (fileSystem.existsSync(absoluteTypesPath)) {
            // Si c'est un fichier .d.ts
            if (absoluteTypesPath.endsWith(".d.ts")) {
              dtsFiles.push(absoluteTypesPath);
              console.log(`üìÑ Fichier de types trouv√©: ${absoluteTypesPath}`);
            }
            // Si c'est un dossier, chercher tous les .d.ts dedans
            else if (fileSystem.statSync(absoluteTypesPath).isDirectory()) {
              collectDtsFiles(absoluteTypesPath, dtsFiles);
            }
          }
        }
      }

      // Chercher dans les emplacements communs si aucun fichier n'a √©t√© trouv√©
      if (dtsFiles.length === 0 || targetLibrary.includes("/")) {
        // Traiter le cas des sous-packages de fa√ßon g√©n√©rique
        if (targetLibrary.includes("/")) {
          const typesDir = path.join(libraryPath, "dist", "types");
          if (fileSystem.existsSync(typesDir)) {
            // Construire le chemin du sous-package (ex: operators pour rxjs/operators)
            const subPackagePath = targetLibrary.substring(
              targetLibrary.indexOf("/") + 1
            );
            const subPackageDir = path.join(typesDir, subPackagePath);

            if (fileSystem.existsSync(subPackageDir)) {
              console.log(
                `üìÅ Dossier de types pour sous-package trouv√©: ${subPackageDir}`
              );
              collectDtsFiles(subPackageDir, dtsFiles);
            }
          }
        }
        // Pour le package principal
        else {
          const typesDir = path.join(libraryPath, "dist", "types");
          if (fileSystem.existsSync(typesDir)) {
            console.log(`üìÅ Dossier de types principal trouv√©: ${typesDir}`);
            collectDtsFiles(typesDir, dtsFiles);
          }
        }

        // Liste des chemins communs o√π chercher les .d.ts
        const commonPaths = [
          path.join(libraryPath, "dist", "types"),
          path.join(libraryPath, "dist"),
          path.join(libraryPath, "lib"),
          path.join(libraryPath, "esm"),
          path.join(libraryPath, "@types"),
          libraryPath
        ];

        // Chercher dans tous les chemins communs
        for (const commonPath of commonPaths) {
          if (fileSystem.existsSync(commonPath)) {
            // console.log(`üîç Recherche dans ${commonPath}...`);
            collectDtsFiles(commonPath, dtsFiles);
          }
        }
      }
    } catch (error) {
      console.warn(
        `‚ö†Ô∏è Erreur lors de la recherche des types pour ${targetLibrary}:`,
        error
      );
    }
  }

  if (dtsFiles.length === 0) {
    throw new Error(
      `Aucun fichier .d.ts trouv√© pour les librairies: ${Array.from(
        targetLibraries
      ).join(", ")}`
    );
  }

  // console.log(
  //   `‚úÖ ${dtsFiles.length} fichiers .d.ts trouv√©s pour ${Array.from(
  //     targetLibraries
  //   ).join(", ")}`
  // );

  return dtsFiles;
}

// Fonction principale export√©e
/**
 * Fonction principale export√©e pour g√©n√©rer un bundle de d√©finitions TypeScript.
 *
 * @param packageDir - Chemin absolu vers le dossier du package source
 */
export async function bundleLibraryDts(pkg: TPackage): Promise<void> {
  console.log(`üîç G√©n√©ration du bundle DTS pour la biblioth√®que: ${pkg.name}`);

  try {
    await generateBundledDts(pkg);
    console.log(`‚úÖ Bundle DTS g√©n√©r√© avec succ√®s pour: ${pkg.name}`);
  } catch (error) {
    console.error(`‚ùå Erreur lors de la g√©n√©ration du bundle DTS:`, error);
    throw error;
  }
}
